from datetime import datetime, date, timedelta, time as dt_time
import re

from aiogram import Router, F, types
from aiogram.filters import StateFilter, Command
from aiogram.fsm.context import FSMContext
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, Message

from states import AdminFSM
from api import ADMIN_IDS
from bd import get_connection


TIME_STEP = 60
admin_router = Router()

# ---------------- ВСПОМОГАТЕЛЬНЫЕ ---------------- #

def valid_date(text: str) -> bool:
    try:
        datetime.strptime(text, "%Y-%m-%d")
        return True
    except ValueError:
        return False

def valid_time(text: str) -> bool:
    return re.fullmatch(r"(?:[01]\d|2[0-3]):[0-5]\d", text) is not None

def format_day(day_iso: str) -> str:
    return datetime.strptime(day_iso, "%Y-%m-%d").strftime("%d.%m.%Y")



async def kb_slots_for_day(day_iso: str) -> InlineKeyboardMarkup:
    date_obj = datetime.strptime(day_iso, "%Y-%m-%d").date()
    async with get_connection() as conn:
        rows = await conn.fetch(
            "SELECT time FROM slots WHERE date = $1 ORDER BY time",
            date_obj
        )

    if not rows:
        return InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="Нет слотов", callback_data="admin:none")],
            [InlineKeyboardButton(text="Назад", callback_data="admin:back")]
        ])

    buttons = []
    row = []
    for r in rows:
        t = r["time"].strftime("%H:%M")
        row.append(InlineKeyboardButton(text=f"{t}", callback_data=f"admin:del_slot:{day_iso}:{t}"))
        if len(row) == 4:  # максимум 4 кнопки в строке
            buttons.append(row)
            row = []
    if row:
        buttons.append(row)

    buttons.append([InlineKeyboardButton(text="Назад", callback_data="admin:back")])
    return InlineKeyboardMarkup(inline_keyboard=buttons)


@admin_router.callback_query(F.data.startswith("admin:del_slot:"))
async def admin_delete_slot(cb: types.CallbackQuery, state: FSMContext):
    parts = cb.data.split(":")
    day_iso = parts[2]
    time_str = ":".join(parts[3:])  # собираем обратно время -> "10:30"

    resp = await del_slot(day_iso, time_str)

    kb = await kb_slots_for_day(day_iso)
    new_text = f"{resp}\nОставшиеся слоты ({format_day(day_iso)}):"

    try:
        await cb.message.edit_text(new_text, reply_markup=kb)
    except TelegramBadRequest as e:
        if "message is not modified" in str(e):
            await cb.answer("Слоты не изменились")
        else:
            raise


def kb_admin() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="Посмотреть слоты", callback_data="admin:view")],
        [InlineKeyboardButton(text="Свободные слоты", callback_data="admin:view_free")],
        [InlineKeyboardButton(text="Занятые слоты", callback_data="admin:view_booked")],
        [InlineKeyboardButton(text="Добавить слот", callback_data="admin:add_slot")],
        [InlineKeyboardButton(text="Удалить слот", callback_data="admin:del_slot")],
        [InlineKeyboardButton(text="Очистить день", callback_data="admin:clear_day")],
        [InlineKeyboardButton(text="Выйти", callback_data="admin:exit")]
    ])

# ---------------- ДЕЙСТВИЯ С БАЗОЙ ---------------- #

async def add_slots(day_iso: str, times: list[str]):
    date_obj = datetime.strptime(day_iso, "%Y-%m-%d").date()
    async with get_connection() as conn:
        for t in times:
            time_obj = dt_time.fromisoformat(t)
            await conn.execute("""
                INSERT INTO slots(date, time, status)
                VALUES ($1, $2, 'free')
                ON CONFLICT (date, time) DO NOTHING
            """, date_obj, time_obj)
    return f"Добавлены слоты: {', '.join(times)} на {format_day(day_iso)}"

async def del_slot(day_iso: str, time_str: str):
    date_obj = datetime.strptime(day_iso, "%Y-%m-%d").date()
    time_obj = dt_time.fromisoformat(time_str)
    async with get_connection() as conn:
        await conn.execute("""
            DELETE FROM slots
            WHERE date = $1 AND time = $2
        """, date_obj, time_obj)
    return f"Слот {time_str} на {format_day(day_iso)} удалён"

async def clear_day(day_iso: str):
    date_obj = datetime.strptime(day_iso, "%Y-%m-%d").date()
    async with get_connection() as conn:
        await conn.execute("DELETE FROM slots WHERE date = $1", date_obj)
    return f"🧹 Все слоты на {format_day(day_iso)} удалены"

# ---------------- ПРОСМОТР СЛОТОВ ---------------- #

async def view_all_free():
    async with get_connection() as conn:
        rows = await conn.fetch("""
            SELECT s.date, s.time
            FROM slots s
            LEFT JOIN bookings b ON s.booking_id = b.id
            WHERE s.status = 'free' AND b.id IS NULL
            ORDER BY s.date, s.time
        """)
    if not rows:
        return "Нет свободных слотов"
    return "Свободные слоты:\n" + "\n".join(
        f"{r['date'].strftime('%d.%m.%Y')} {r['time'].strftime('%H:%M')}" for r in rows
    )

async def view_all_booked():
    async with get_connection() as conn:
        rows = await conn.fetch("""
            SELECT s.date, s.time, b.user_id, b.service, b.sub_service
            FROM slots s
            JOIN bookings b ON s.booking_id = b.id
            ORDER BY s.date, s.time
        """)
    if not rows:
        return "Нет занятых слотов"
    return "Занятые слоты:\n" + "\n".join(
        f"{r['date'].strftime('%d.%m.%Y')} {r['time'].strftime('%H:%M')} — {r['service']} ({r['sub_service']}) [user {r['user_id']}]"
        for r in rows
    )

async def view_all_slots():
    async with get_connection() as conn:
        rows = await conn.fetch("""
            SELECT s.date, s.time, s.status, b.user_id, b.service, b.sub_service
            FROM slots s
            LEFT JOIN bookings b ON s.booking_id = b.id
            ORDER BY s.date, s.time
        """)
    if not rows:
        return "Слотов нет"
    lines = []
    for r in rows:
        if r["status"] == "free" and r["user_id"] is None:
            lines.append(f"{r['date'].strftime('%d.%m.%Y')} {r['time'].strftime('%H:%M')} — свободно")
        else:
            lines.append(
                f"{r['date'].strftime('%d.%m.%Y')} {r['time'].strftime('%H:%M')} — занято ({r['service']}, user {r['user_id']})"
            )
    return "Все слоты:\n" + "\n".join(lines)

# ---------------- КНОПКИ ДАТ ---------------- #

async def kb_days_admin(days_ahead: int = 30) -> InlineKeyboardMarkup:
    today = date.today()
    end_day = today + timedelta(days=days_ahead)

    async with get_connection() as conn:
        rows = await conn.fetch("""
            SELECT date, COUNT(*) AS c
            FROM slots
            WHERE date BETWEEN $1 AND $2
            GROUP BY date
        """, today, end_day)

    counters = {r["date"]: r["c"] for r in rows}

    buttons = []
    cur = today
    row = []
    while cur <= end_day:
        day_iso = cur.isoformat()
        count = counters.get(cur, 0)
        text = f"{cur.strftime('%d.%m')} ({count})" if count else cur.strftime("%d.%m")
        row.append(InlineKeyboardButton(text=text, callback_data=f"admin:day:{day_iso}"))

        # делаем сетку 7xN
        if len(row) == 7:
            buttons.append(row)
            row = []

        cur += timedelta(days=1)

    if row:
        buttons.append(row)

    buttons.append([InlineKeyboardButton(text="Назад", callback_data="admin:back")])
    return InlineKeyboardMarkup(inline_keyboard=buttons)

# ---------------- ХЕНДЛЕРЫ ---------------- #

@admin_router.message(Command("admin"))
async def admin_start(message: Message, state: FSMContext):
    if message.from_user.id not in ADMIN_IDS:
        await message.answer("⛔ У вас нет доступа к админ-панели.")
        return
    await state.clear()
    await message.answer("Админ-панель:", reply_markup=kb_admin())

# просмотр всех слотов
@admin_router.callback_query(F.data.in_(["admin:view", "admin:view_free", "admin:view_booked"]))
async def handle_admin_view(cb: types.CallbackQuery, state: FSMContext):
    await cb.answer()
    action = cb.data.split(":", 1)[1]

    if action == "view":
        resp = await view_all_slots()
    elif action == "view_free":
        resp = await view_all_free()
    elif action == "view_booked":
        resp = await view_all_booked()
    else:
        resp = "Неизвестное действие"

    await cb.message.edit_text(resp, reply_markup=kb_admin())
    await state.clear()

# добавление/удаление/очистка дня
@admin_router.callback_query(F.data.in_(["admin:add_slot", "admin:del_slot", "admin:clear_day", "admin:exit"]))
async def handle_admin_dates(cb: types.CallbackQuery, state: FSMContext):
    await cb.answer()
    action = cb.data.split(":", 1)[1]

    if action == "exit":
        await state.clear()
        await cb.message.edit_text("Вы вышли из админ панели")
        return


    if action == "del_slot":
        kb = await kb_days_with_slots_admin()
        await state.update_data(admin_action="del_slot")
        await state.set_state(AdminFSM.day)
        await cb.message.edit_text("Выберите день со слотами:", reply_markup=kb)
        return

    await state.update_data(admin_action=action)
    await state.set_state(AdminFSM.day)

    kb = await kb_days_admin()
    await cb.message.edit_text("Выберите дату:", reply_markup=kb)

@admin_router.callback_query(F.data.startswith("admin:day:"), StateFilter(AdminFSM.day))
async def admin_pick_day(cb: types.CallbackQuery, state: FSMContext):
    await cb.answer()
    day_iso = cb.data.split(":", 2)[2]

    if not valid_date(day_iso):
        await cb.answer("Неверная дата", show_alert=True)
        return

    data = await state.get_data()
    action = data.get("admin_action")

    if action == "add_slot":
        await state.update_data(day=day_iso)
        await state.set_state(AdminFSM.time)
        await cb.message.edit_text(
            f"Введите время (например: 10:00, 11:30 или 10:00-12:00) для {format_day(day_iso)}:"
        )
        return

    if action == "del_slot":
        # получаем клавиатуру со слотами для конкретного дня
        kb = await kb_slots_for_day(day_iso)
        await state.update_data(day=day_iso)  # запоминаем выбранный день
        await state.set_state(AdminFSM.time)  # состояние для выбора слота
        new_text = f"Выберите слот для удаления ({format_day(day_iso)}):"
        await cb.message.edit_text(new_text, reply_markup=kb)
        return






    elif action == "clear_day":
        resp = await clear_day(day_iso)
    else:
        resp = "Неизвестное действие"

    await cb.message.edit_text(resp, reply_markup=kb_admin())
    await state.clear()

# добавление/удаление времени
@admin_router.message(StateFilter(AdminFSM.time))
async def admin_add_times(message: types.Message, state: FSMContext):
    data = await state.get_data()
    day = data.get("day")
    action = data.get("admin_action")

    raw = message.text.strip()
    parts = [p.strip() for p in raw.split(",") if p.strip()]
    times, bad = [], []

    for p in parts:
        if "-" in p:
            try:
                start, end = [x.strip() for x in p.split("-")]
                if not (valid_time(start) and valid_time(end)):
                    bad.append(p)
                    continue
                cur = datetime.strptime(start, "%H:%M")
                end_dt = datetime.strptime(end, "%H:%M")
                while cur <= end_dt:
                    times.append(cur.strftime("%H:%M"))
                    cur += timedelta(minutes=TIME_STEP)
            except Exception:
                bad.append(p)
        else:
            if valid_time(p):
                times.append(p)
            else:
                bad.append(p)

    if action == "add_slot":
        resp = await add_slots(day, times)
    elif action == "del_slot":
        for t in times:
            await del_slot(day, t)
        resp = f"Удалены слоты: {', '.join(times)} на {format_day(day)}"
    else:
        resp = "Ошибка: неизвестное действие"

    if bad:
        resp += f"\nНекорректные форматы: {', '.join(bad)}"

    await message.answer(resp, reply_markup=kb_admin())
    await state.clear()

# служебные
@admin_router.callback_query(F.data == "admin:back")
async def admin_back(cb: types.CallbackQuery, state: FSMContext):
    await cb.answer()
    await cb.message.edit_text("🛠 Админ-панель:", reply_markup=kb_admin())
    await state.clear()

@admin_router.callback_query(F.data == "admin:cancel")
async def admin_cancel(cb: types.CallbackQuery, state: FSMContext):
    await state.clear()
    await cb.message.edit_text("Действие отменено.", reply_markup=kb_admin())


async def kb_days_with_slots_admin() -> InlineKeyboardMarkup:
    async with get_connection() as conn:
        rows = await conn.fetch("""
            SELECT s.date,
                   SUM(CASE WHEN s.status = 'free' THEN 1 ELSE 0 END) AS free_count,
                   SUM(CASE WHEN s.status = 'booked' THEN 1 ELSE 0 END) AS booked_count
            FROM slots s
            GROUP BY s.date
            ORDER BY s.date
        """)

    if not rows:
        return InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="Нет слотов", callback_data="admin:none")],
            [InlineKeyboardButton(text="Назад", callback_data="admin:back")]
        ])

    buttons = []
    row = []
    for r in rows:
        day_iso = r["date"].isoformat()
        free_count = r["free_count"]
        booked_count = r["booked_count"]

        if free_count and booked_count:
            text = f"{r['date'].strftime('%d.%m')}{free_count} 📌{booked_count}"
        elif free_count:
            text = f"{r['date'].strftime('%d.%m')}{free_count}"
        else:
            text = f"{r['date'].strftime('%d.%m')}{booked_count}"

        row.append(InlineKeyboardButton(text=text, callback_data=f"admin:day:{day_iso}"))

        if len(row) == 4:
            buttons.append(row)
            row = []

    if row:
        buttons.append(row)

    buttons.append([InlineKeyboardButton(text="Назад", callback_data="admin:back")])
    return InlineKeyboardMarkup(inline_keyboard=buttons)




