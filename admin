from datetime import datetime, date, timedelta, time as dt_time
import re

from aiogram import Router, F, types
from aiogram.filters import StateFilter, Command
from aiogram.fsm.context import FSMContext
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, Message

from states import AdminFSM
from api import ADMIN_IDS
from bd import get_connection


TIME_STEP = 60
admin_router = Router()

# ---------------- –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï ---------------- #

def valid_date(text: str) -> bool:
    try:
        datetime.strptime(text, "%Y-%m-%d")
        return True
    except ValueError:
        return False

def valid_time(text: str) -> bool:
    return re.fullmatch(r"(?:[01]\d|2[0-3]):[0-5]\d", text) is not None

def format_day(day_iso: str) -> str:
    return datetime.strptime(day_iso, "%Y-%m-%d").strftime("%d.%m.%Y")



async def kb_slots_for_day(day_iso: str) -> InlineKeyboardMarkup:
    date_obj = datetime.strptime(day_iso, "%Y-%m-%d").date()
    async with get_connection() as conn:
        rows = await conn.fetch(
            "SELECT time FROM slots WHERE date = $1 ORDER BY time",
            date_obj
        )

    if not rows:
        return InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="–ù–µ—Ç —Å–ª–æ—Ç–æ–≤", callback_data="admin:none")],
            [InlineKeyboardButton(text="–ù–∞–∑–∞–¥", callback_data="admin:back")]
        ])

    buttons = []
    row = []
    for r in rows:
        t = r["time"].strftime("%H:%M")
        row.append(InlineKeyboardButton(text=f"{t}", callback_data=f"admin:del_slot:{day_iso}:{t}"))
        if len(row) == 4:  # –º–∞–∫—Å–∏–º—É–º 4 –∫–Ω–æ–ø–∫–∏ –≤ —Å—Ç—Ä–æ–∫–µ
            buttons.append(row)
            row = []
    if row:
        buttons.append(row)

    buttons.append([InlineKeyboardButton(text="–ù–∞–∑–∞–¥", callback_data="admin:back")])
    return InlineKeyboardMarkup(inline_keyboard=buttons)


@admin_router.callback_query(F.data.startswith("admin:del_slot:"))
async def admin_delete_slot(cb: types.CallbackQuery, state: FSMContext):
    parts = cb.data.split(":")
    day_iso = parts[2]
    time_str = ":".join(parts[3:])  # —Å–æ–±–∏—Ä–∞–µ–º –æ–±—Ä–∞—Ç–Ω–æ –≤—Ä–µ–º—è -> "10:30"

    resp = await del_slot(day_iso, time_str)

    kb = await kb_slots_for_day(day_iso)
    new_text = f"{resp}\n–û—Å—Ç–∞–≤—à–∏–µ—Å—è —Å–ª–æ—Ç—ã ({format_day(day_iso)}):"

    try:
        await cb.message.edit_text(new_text, reply_markup=kb)
    except TelegramBadRequest as e:
        if "message is not modified" in str(e):
            await cb.answer("–°–ª–æ—Ç—ã –Ω–µ –∏–∑–º–µ–Ω–∏–ª–∏—Å—å")
        else:
            raise


def kb_admin() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="–ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Å–ª–æ—Ç—ã", callback_data="admin:view")],
        [InlineKeyboardButton(text="–°–≤–æ–±–æ–¥–Ω—ã–µ —Å–ª–æ—Ç—ã", callback_data="admin:view_free")],
        [InlineKeyboardButton(text="–ó–∞–Ω—è—Ç—ã–µ —Å–ª–æ—Ç—ã", callback_data="admin:view_booked")],
        [InlineKeyboardButton(text="–î–æ–±–∞–≤–∏—Ç—å —Å–ª–æ—Ç", callback_data="admin:add_slot")],
        [InlineKeyboardButton(text="–£–¥–∞–ª–∏—Ç—å —Å–ª–æ—Ç", callback_data="admin:del_slot")],
        [InlineKeyboardButton(text="–û—á–∏—Å—Ç–∏—Ç—å –¥–µ–Ω—å", callback_data="admin:clear_day")],
        [InlineKeyboardButton(text="–í—ã–π—Ç–∏", callback_data="admin:exit")]
    ])

# ---------------- –î–ï–ô–°–¢–í–ò–Ø –° –ë–ê–ó–û–ô ---------------- #

async def add_slots(day_iso: str, times: list[str]):
    date_obj = datetime.strptime(day_iso, "%Y-%m-%d").date()
    async with get_connection() as conn:
        for t in times:
            time_obj = dt_time.fromisoformat(t)
            await conn.execute("""
                INSERT INTO slots(date, time, status)
                VALUES ($1, $2, 'free')
                ON CONFLICT (date, time) DO NOTHING
            """, date_obj, time_obj)
    return f"–î–æ–±–∞–≤–ª–µ–Ω—ã —Å–ª–æ—Ç—ã: {', '.join(times)} –Ω–∞ {format_day(day_iso)}"

async def del_slot(day_iso: str, time_str: str):
    date_obj = datetime.strptime(day_iso, "%Y-%m-%d").date()
    time_obj = dt_time.fromisoformat(time_str)
    async with get_connection() as conn:
        await conn.execute("""
            DELETE FROM slots
            WHERE date = $1 AND time = $2
        """, date_obj, time_obj)
    return f"–°–ª–æ—Ç {time_str} –Ω–∞ {format_day(day_iso)} —É–¥–∞–ª—ë–Ω"

async def clear_day(day_iso: str):
    date_obj = datetime.strptime(day_iso, "%Y-%m-%d").date()
    async with get_connection() as conn:
        await conn.execute("DELETE FROM slots WHERE date = $1", date_obj)
    return f"üßπ –í—Å–µ —Å–ª–æ—Ç—ã –Ω–∞ {format_day(day_iso)} —É–¥–∞–ª–µ–Ω—ã"

# ---------------- –ü–†–û–°–ú–û–¢–† –°–õ–û–¢–û–í ---------------- #

async def view_all_free():
    async with get_connection() as conn:
        rows = await conn.fetch("""
            SELECT s.date, s.time
            FROM slots s
            LEFT JOIN bookings b ON s.booking_id = b.id
            WHERE s.status = 'free' AND b.id IS NULL
            ORDER BY s.date, s.time
        """)
    if not rows:
        return "–ù–µ—Ç —Å–≤–æ–±–æ–¥–Ω—ã—Ö —Å–ª–æ—Ç–æ–≤"
    return "–°–≤–æ–±–æ–¥–Ω—ã–µ —Å–ª–æ—Ç—ã:\n" + "\n".join(
        f"{r['date'].strftime('%d.%m.%Y')} {r['time'].strftime('%H:%M')}" for r in rows
    )

async def view_all_booked():
    async with get_connection() as conn:
        rows = await conn.fetch("""
            SELECT s.date, s.time, b.user_id, b.service, b.sub_service
            FROM slots s
            JOIN bookings b ON s.booking_id = b.id
            ORDER BY s.date, s.time
        """)
    if not rows:
        return "–ù–µ—Ç –∑–∞–Ω—è—Ç—ã—Ö —Å–ª–æ—Ç–æ–≤"
    return "–ó–∞–Ω—è—Ç—ã–µ —Å–ª–æ—Ç—ã:\n" + "\n".join(
        f"{r['date'].strftime('%d.%m.%Y')} {r['time'].strftime('%H:%M')} ‚Äî {r['service']} ({r['sub_service']}) [user {r['user_id']}]"
        for r in rows
    )

async def view_all_slots():
    async with get_connection() as conn:
        rows = await conn.fetch("""
            SELECT s.date, s.time, s.status, b.user_id, b.service, b.sub_service
            FROM slots s
            LEFT JOIN bookings b ON s.booking_id = b.id
            ORDER BY s.date, s.time
        """)
    if not rows:
        return "–°–ª–æ—Ç–æ–≤ –Ω–µ—Ç"
    lines = []
    for r in rows:
        if r["status"] == "free" and r["user_id"] is None:
            lines.append(f"{r['date'].strftime('%d.%m.%Y')} {r['time'].strftime('%H:%M')} ‚Äî —Å–≤–æ–±–æ–¥–Ω–æ")
        else:
            lines.append(
                f"{r['date'].strftime('%d.%m.%Y')} {r['time'].strftime('%H:%M')} ‚Äî –∑–∞–Ω—è—Ç–æ ({r['service']}, user {r['user_id']})"
            )
    return "–í—Å–µ —Å–ª–æ—Ç—ã:\n" + "\n".join(lines)

# ---------------- –ö–ù–û–ü–ö–ò –î–ê–¢ ---------------- #

async def kb_days_admin(days_ahead: int = 30) -> InlineKeyboardMarkup:
    today = date.today()
    end_day = today + timedelta(days=days_ahead)

    async with get_connection() as conn:
        rows = await conn.fetch("""
            SELECT date, COUNT(*) AS c
            FROM slots
            WHERE date BETWEEN $1 AND $2
            GROUP BY date
        """, today, end_day)

    counters = {r["date"]: r["c"] for r in rows}

    buttons = []
    cur = today
    row = []
    while cur <= end_day:
        day_iso = cur.isoformat()
        count = counters.get(cur, 0)
        text = f"{cur.strftime('%d.%m')} ({count})" if count else cur.strftime("%d.%m")
        row.append(InlineKeyboardButton(text=text, callback_data=f"admin:day:{day_iso}"))

        # –¥–µ–ª–∞–µ–º —Å–µ—Ç–∫—É 7xN
        if len(row) == 7:
            buttons.append(row)
            row = []

        cur += timedelta(days=1)

    if row:
        buttons.append(row)

    buttons.append([InlineKeyboardButton(text="–ù–∞–∑–∞–¥", callback_data="admin:back")])
    return InlineKeyboardMarkup(inline_keyboard=buttons)

# ---------------- –•–ï–ù–î–õ–ï–†–´ ---------------- #

@admin_router.message(Command("admin"))
async def admin_start(message: Message, state: FSMContext):
    if message.from_user.id not in ADMIN_IDS:
        await message.answer("‚õî –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏.")
        return
    await state.clear()
    await message.answer("–ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å:", reply_markup=kb_admin())

# –ø—Ä–æ—Å–º–æ—Ç—Ä –≤—Å–µ—Ö —Å–ª–æ—Ç–æ–≤
@admin_router.callback_query(F.data.in_(["admin:view", "admin:view_free", "admin:view_booked"]))
async def handle_admin_view(cb: types.CallbackQuery, state: FSMContext):
    await cb.answer()
    action = cb.data.split(":", 1)[1]

    if action == "view":
        resp = await view_all_slots()
    elif action == "view_free":
        resp = await view_all_free()
    elif action == "view_booked":
        resp = await view_all_booked()
    else:
        resp = "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ"

    await cb.message.edit_text(resp, reply_markup=kb_admin())
    await state.clear()

# –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ/—É–¥–∞–ª–µ–Ω–∏–µ/–æ—á–∏—Å—Ç–∫–∞ –¥–Ω—è
@admin_router.callback_query(F.data.in_(["admin:add_slot", "admin:del_slot", "admin:clear_day", "admin:exit"]))
async def handle_admin_dates(cb: types.CallbackQuery, state: FSMContext):
    await cb.answer()
    action = cb.data.split(":", 1)[1]

    if action == "exit":
        await state.clear()
        await cb.message.edit_text("–í—ã –≤—ã—à–ª–∏ –∏–∑ –∞–¥–º–∏–Ω –ø–∞–Ω–µ–ª–∏")
        return


    if action == "del_slot":
        kb = await kb_days_with_slots_admin()
        await state.update_data(admin_action="del_slot")
        await state.set_state(AdminFSM.day)
        await cb.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–Ω—å —Å–æ —Å–ª–æ—Ç–∞–º–∏:", reply_markup=kb)
        return

    await state.update_data(admin_action=action)
    await state.set_state(AdminFSM.day)

    kb = await kb_days_admin()
    await cb.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ –¥–∞—Ç—É:", reply_markup=kb)

@admin_router.callback_query(F.data.startswith("admin:day:"), StateFilter(AdminFSM.day))
async def admin_pick_day(cb: types.CallbackQuery, state: FSMContext):
    await cb.answer()
    day_iso = cb.data.split(":", 2)[2]

    if not valid_date(day_iso):
        await cb.answer("–ù–µ–≤–µ—Ä–Ω–∞—è –¥–∞—Ç–∞", show_alert=True)
        return

    data = await state.get_data()
    action = data.get("admin_action")

    if action == "add_slot":
        await state.update_data(day=day_iso)
        await state.set_state(AdminFSM.time)
        await cb.message.edit_text(
            f"–í–≤–µ–¥–∏—Ç–µ –≤—Ä–µ–º—è (–Ω–∞–ø—Ä–∏–º–µ—Ä: 10:00, 11:30 –∏–ª–∏ 10:00-12:00) –¥–ª—è {format_day(day_iso)}:"
        )
        return

    if action == "del_slot":
        # –ø–æ–ª—É—á–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å–æ —Å–ª–æ—Ç–∞–º–∏ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –¥–Ω—è
        kb = await kb_slots_for_day(day_iso)
        await state.update_data(day=day_iso)  # –∑–∞–ø–æ–º–∏–Ω–∞–µ–º –≤—ã–±—Ä–∞–Ω–Ω—ã–π –¥–µ–Ω—å
        await state.set_state(AdminFSM.time)  # —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –≤—ã–±–æ—Ä–∞ —Å–ª–æ—Ç–∞
        new_text = f"–í—ã–±–µ—Ä–∏—Ç–µ —Å–ª–æ—Ç –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è ({format_day(day_iso)}):"
        await cb.message.edit_text(new_text, reply_markup=kb)
        return






    elif action == "clear_day":
        resp = await clear_day(day_iso)
    else:
        resp = "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ"

    await cb.message.edit_text(resp, reply_markup=kb_admin())
    await state.clear()

# –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ/—É–¥–∞–ª–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏
@admin_router.message(StateFilter(AdminFSM.time))
async def admin_add_times(message: types.Message, state: FSMContext):
    data = await state.get_data()
    day = data.get("day")
    action = data.get("admin_action")

    raw = message.text.strip()
    parts = [p.strip() for p in raw.split(",") if p.strip()]
    times, bad = [], []

    for p in parts:
        if "-" in p:
            try:
                start, end = [x.strip() for x in p.split("-")]
                if not (valid_time(start) and valid_time(end)):
                    bad.append(p)
                    continue
                cur = datetime.strptime(start, "%H:%M")
                end_dt = datetime.strptime(end, "%H:%M")
                while cur <= end_dt:
                    times.append(cur.strftime("%H:%M"))
                    cur += timedelta(minutes=TIME_STEP)
            except Exception:
                bad.append(p)
        else:
            if valid_time(p):
                times.append(p)
            else:
                bad.append(p)

    if action == "add_slot":
        resp = await add_slots(day, times)
    elif action == "del_slot":
        for t in times:
            await del_slot(day, t)
        resp = f"–£–¥–∞–ª–µ–Ω—ã —Å–ª–æ—Ç—ã: {', '.join(times)} –Ω–∞ {format_day(day)}"
    else:
        resp = "–û—à–∏–±–∫–∞: –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ"

    if bad:
        resp += f"\n–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã: {', '.join(bad)}"

    await message.answer(resp, reply_markup=kb_admin())
    await state.clear()

# —Å–ª—É–∂–µ–±–Ω—ã–µ
@admin_router.callback_query(F.data == "admin:back")
async def admin_back(cb: types.CallbackQuery, state: FSMContext):
    await cb.answer()
    await cb.message.edit_text("üõ† –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å:", reply_markup=kb_admin())
    await state.clear()

@admin_router.callback_query(F.data == "admin:cancel")
async def admin_cancel(cb: types.CallbackQuery, state: FSMContext):
    await state.clear()
    await cb.message.edit_text("–î–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=kb_admin())


async def kb_days_with_slots_admin() -> InlineKeyboardMarkup:
    async with get_connection() as conn:
        rows = await conn.fetch("""
            SELECT s.date,
                   SUM(CASE WHEN s.status = 'free' THEN 1 ELSE 0 END) AS free_count,
                   SUM(CASE WHEN s.status = 'booked' THEN 1 ELSE 0 END) AS booked_count
            FROM slots s
            GROUP BY s.date
            ORDER BY s.date
        """)

    if not rows:
        return InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="–ù–µ—Ç —Å–ª–æ—Ç–æ–≤", callback_data="admin:none")],
            [InlineKeyboardButton(text="–ù–∞–∑–∞–¥", callback_data="admin:back")]
        ])

    buttons = []
    row = []
    for r in rows:
        day_iso = r["date"].isoformat()
        free_count = r["free_count"]
        booked_count = r["booked_count"]

        if free_count and booked_count:
            text = f"{r['date'].strftime('%d.%m')}{free_count} üìå{booked_count}"
        elif free_count:
            text = f"{r['date'].strftime('%d.%m')}{free_count}"
        else:
            text = f"{r['date'].strftime('%d.%m')}{booked_count}"

        row.append(InlineKeyboardButton(text=text, callback_data=f"admin:day:{day_iso}"))

        if len(row) == 4:
            buttons.append(row)
            row = []

    if row:
        buttons.append(row)

    buttons.append([InlineKeyboardButton(text="–ù–∞–∑–∞–¥", callback_data="admin:back")])
    return InlineKeyboardMarkup(inline_keyboard=buttons)




